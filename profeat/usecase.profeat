mdp

const int max_height = 6;
const int min_height = 1;
const int max_visibility = 12;
const int min_visibility = 1;
const double current_probability = 0.6;
const double sun_probability = 0.4; 

//I don't know why I can't update the water visibility...
global water_visibility : [min_visibility..max_visibility] init 5;

////////////////
// feature model
///////////////
root feature
    all of low, optional medium, high;

	modules auv, environment;
endfeature

// An active feature low means that the AUV is *able to go to the low altitude*. An active feature low_altitude means that the AUV is *at a low altitude*
feature low
	all of optional low_altitude;

	constraint active(low_altitude) => !active(medium_altitude) & !active(high_altitude);

    rewards "efficiency"
    	[b1] active(this) & !active(medium) & !active(high) : 1;
    	
    	[b10] active(this) & !active(medium) & !active(high) : 0.25;
    	[b11] active(this) & !active(medium) & !active(high) : 0;
    	[b12] active(this) & !active(medium) & !active(high) : 2;
    	[b13] active(this) & !active(medium) & !active(high) : 1;
    	[b15] active(this) & !active(medium) & !active(high) : 1;
    	[b16] active(this) & !active(medium) & !active(high) : 1;
    	[b17] active(this) & !active(medium) & !active(high) : 1;
    	[b18] active(this) & !active(medium) & !active(high) : 1;
    endrewards
endfeature

// An active feature medium means that the AUV is *able to go to the medium altitude*. An active feature medium_altitude means that the AUV is *at a medium altitude*
feature medium
	all of optional medium_altitude;

	constraint active(medium_altitude) => !active(medium_altitude) & !active(high_altitude);

	rewards "efficiency"
		[b1] active(this) & !active(high) : 1;
		[b2] active(this) & !active(high) : 2;
		
		[b10] active(this) & !active(high) : 0.25;
		[b11] active(this) & !active(high) : 0;
		[b12] active(this) & !active(high) : 2;
		[b13] active(this) & !active(high) : 1;
		[b15] active(this) & !active(high) : 1;
		[b16] active(this) & !active(high) : 1;
		[b17] active(this) & !active(high) : 1;
		[b18] active(this) & !active(high) : 1;
	endrewards
endfeature

// An active feature high means that the AUV is *able to go to the high altitude*. An active feature high_altitude means that the AUV is *at a high altitude*
feature high
	all of optional high_altitude;
	
	constraint active(high_altitude) => !active(low_altitude) & !active(medium_altitude);

    rewards "efficiency"
    	[b0] active(this) : 0.5;
    	[b1] active(this) : 1;
    	[b2] active(this) : 2;
    	
    	[b9] active(this) : 0.5;
    	[b10] active(this) : 0.25;
    	[b11] active(this) : 0;
    	[b12] active(this) : 2;
    	[b13] active(this) : 1;
    	[b14] active(this) : 1;
    	[b15] active(this) : 1;
    	[b16] active(this) : 1;
    	[b17] active(this) : 1;
    	[b18] active(this) : 1;
    endrewards
endfeature

feature low_altitude endfeature
feature medium_altitude endfeature
feature high_altitude endfeature


///////////////////
// formulas
//////////////////
formula flow = (active(low)? 1 : 0); 
formula fmedium = (active(medium)? 1 : 0); 
formula fhigh = (active(high)? 1 : 0); 

/////////////////////
// states
////////////////////
//"normal" states
const int start = 0;
const int search_high = 1;
const int search_medium = 2;
const int search_low = 3;
const int found = 4;
const int follow = 5;
const int recover_start = 6;
const int recover_high = 7;
const int recover_medium = 8;
const int recover_low = 9;
const int recover_found = 10;
const int recover_follow = 11;

//from start to searching state
const int start2search_high = 12;
const int start2search_medium = 13;
const int start2search_low = 14;
//self loops recovery states
const int recover_start2recover_start = 15;
const int recover_high2recover_high = 16;
const int recover_medium2recover_medium = 17;
const int recover_low2recover_low = 18;
const int recover_found2recover_found = 19;
const int recover_follow2recover_follow = 20;
//from searching state to found
const int search_high2found = 21;
const int search_medium2found = 22;
const int search_low2found = 23;
//no intermediate state from found to follow
//from follow to search low (pipeline lost)
const int follow2search_low = 24;
//to recover state
const int search_high2recover_high = 25;
const int search_medium2recover_medium = 26;
const int search_low2recover_low = 27;
const int found2recover_found = 28;
const int follow2recover_follow = 29;
const int start2recover_start = 30;
//final state
const int done = 31;
//self loops "normal" states
const int search_high2search_high = 32;
const int search_medium2search_medium = 34;
const int search_low2search_low = 35;
const int follow2follow = 36;



/////////////////////
/// modules
////////////////////

// TODO: Update water visibility here (but doesn't work at the moment)

//The environment module models the changes in the water visibility
//We could also add the thruster failures here, maybe the thrusters fail more in certain conditions than others
//If there is a current, then the water visibility reduces by 1, if there is not, it increases by 1
//If there is sun, the water visibility increases by 1, if not, then it reduces by 1
//In this way, the currents and sun can cancel each other out and the water visibility has changes [-2..2] each step
module environment
	current_visibility : [min_visibility..max_visibility];
	// In every step (to an intermediate state if it is there, or a normal state if no intermediate state is there), the water visibility changes depending on the current_probability
	[step] true -> current_probability: (current_visibility'= (current_visibility=min_visibility? min_visibility : current_visibility-1))
					+ (1-current_probability): (current_visibility'= (current_visibility=max_visibility? max_visibility : current_visibility+1));
	// In every step (to an intermediate state if it is there, or a normal state if no intermediate state is there), the water visibility changes depending on the sun_probability
	[step] true -> (1-sun_probability): (current_visibility'= (current_visibility=min_visibility? min_visibility : current_visibility-1))
					+ sun_probability: (current_visibility'= (current_visibility=max_visibility? max_visibility : current_visibility+1));
endmodule

module auv
	s : [0..36] init start;
	[step] (s=start & water_visibility<=2) -> (fmedium)*(fhigh)*0.05:(s'=start2search_high) 						// the changes depend on the water visibility
												+ (1-fmedium)*(fhigh)*0.1:(s'=start2search_high)
												+ (fmedium)*(fhigh)*0.1:(s'=start2search_medium) 		// case medium and high active
												+ (fmedium)*(1-fhigh)*0.15:(s'=start2search_medium) 	// case medium active, high inactive
												+ (fmedium)*(fhigh)*0.8:(s'=start2search_low) 					// case medium active
												+ (1-fmedium)*(fhigh)*0.85:(s'=start2search_low) 				// case medium inactive
												+ (1-fmedium)*(1-fhigh)*0.95: (s'=start2search_low)				//case both medium and high inactive
												+ 0.05:(s'=start2recover_start);
	[step] (s=start & 2<water_visibility & water_visibility<=5) -> (fhigh)*(fmedium)*0.1:(s'=start2search_high) 	// case high and medium active
												+ (fhigh)*(1-fmedium)*0.45:(s'=start2search_high)		// case high active, medium inactive
												+ (fmedium)*(fhigh)*0.7:(s'=start2search_medium) 		// case medium and high active
												+ (fmedium)*(1-fhigh)*0.8:(s'=start2search_medium) 		// case medium active, high inactive
												+ (fmedium)*0.15:(s'=start2search_low) 					// case medium active
												+ (1-fmedium)*0.5:(s'=start2search_low) 				// case medium inactive
												+ 0.05:(s'=start2recover_start);
	[step] (s=start & 5<water_visibility) -> (fhigh)*(fmedium)*0.8:(s'=start2search_high) 				// case high and medium active
												+ (fhigh)*(1-fmedium)*0.85:(s'=start2search_high) 		// case high active, medium inactive
												+ (fmedium)*(fhigh)*0.1:(s'=start2search_medium) 		// case medium and high active
												+ (fmedium)*(1-fhigh)*0.9:(s'=start2search_medium) 		// case medium active, high inactive
												+ (fmedium)*0.05:(s'=start2search_low) 					// case medium active
												+ (1-fmedium)*0.1:(s'=start2search_low) 				// case medium inactive
												+ 0.05:(s'=start2recover_start);
	[step] (s=search_high & active(high)) -> 0.55:(s'=search_high2found) 
						+ 0.4:(s'=search_high2search_high)
						+ 0.05:(s'=search_high2recover_high);
	[step] (s=search_medium & active(medium)) -> 0.45:(s'=search_medium2found) 
						+ 0.5: (s'=search_medium2search_medium)
						+ 0.05:(s'=search_medium2recover_medium);
	[step] (s=search_low) -> 0.35:(s'=search_low2found) 
						+ 0.6: (s'=search_low2search_low)
						+ 0.05:(s'=search_low2recover_low);
	[step] (s=found) -> 0.95:(s'=follow) 
						+ 0.05:(s'=found2recover_found);
	[step] (s=follow) -> 0.2:(s'=follow2search_low) 
						+ 0.4: (s'=follow2follow)
						+ 0.35:(s'=done) 
						+ 0.05:(s'=recover_follow);
	[step] (s=recover_start) -> 0.5:(s'=recover_start2recover_start) 
						+ 0.5:(s'=start);
	[step] (s=recover_high) -> 0.5:(s'=recover_high2recover_high) 
						+ 0.5:(s'=search_high);
	[step] (s=recover_medium) -> 0.5:(s'=recover_medium2recover_medium) 
						+ 0.5:(s'=search_medium);
	[step] (s=recover_low) -> 0.5:(s'=recover_low2recover_low) 
						+ 0.5:(s'=search_low);
	[step] (s=recover_found) -> 0.5:(s'=recover_found2recover_found) 
						+ 0.5:(s'=found);
	[step] (s=recover_follow) -> 0.5:(s'=recover_follow2recover_follow) 
						+ 0.5:(s'=follow);

	//intermediate states
	//from start to search
	[b0] (s=start2search_high) -> 1:(s'=search_high);
	[b1] (s=start2search_medium) -> 1:(s'=search_medium);
	[b2] (s=start2search_low) -> 1:(s'=search_low);
	//self loops recover
	[b3] (s=recover_start2recover_start) -> 1:(s'=recover_start);
	[b4] (s=recover_high2recover_high) -> 1:(s'=recover_high);
	[b5] (s=recover_medium2recover_medium) -> 1:(s'=recover_medium);
	[b6] (s=recover_low2recover_low) -> 1:(s'=recover_low);
	[b7] (s=recover_found2recover_found) -> 1:(s'=recover_found);
	[b8] (s=recover_follow2recover_follow) -> 1:(s'=recover_follow);
	//from search to found
	[b9] (s=search_high2found) -> 1:(s'=found);
	[b10] (s=search_medium2found) -> 1:(s'=found);
	[b11] (s=search_low2found) -> 1:(s'=found);
	//from follow to search_low
	[b12] (s=follow2search_low) -> 1:(s'=search_low);
	//to recover
	[b13] (s=start2recover_start) -> 1:(s'=recover_start);
	[b14] (s=search_high2recover_high) -> 1:(s'=recover_high);
	[b15] (s=search_medium2recover_medium) -> 1:(s'=recover_medium);
	[b16] (s=search_low2recover_low) -> 1:(s'=recover_low);
	[b17] (s=found2recover_found) -> 1:(s'=recover_found);
	[b18] (s=follow2recover_follow) -> 1:(s'=recover_follow);
	//self loops "normal" states
	[b25] (s=search_high2search_high) -> 1:(s'=search_high);
	[b26] (s=search_medium2search_medium) -> 1:(s'=search_medium);
	[b27] (s=search_low2search_low) -> 1:(s'=search_low);
	[b28] (s=follow2follow) -> 1:(s'=follow); 
endmodule
